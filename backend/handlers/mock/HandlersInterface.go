// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/nimitsarup/rep/handlers"
	"sync"
)

// Ensure, that HandlersInterfaceMock does implement handlers.HandlersInterface.
// If this is not the case, regenerate this file with moq.
var _ handlers.HandlersInterface = &HandlersInterfaceMock{}

// HandlersInterfaceMock is a mock implementation of handlers.HandlersInterface.
//
//	func TestSomethingThatUsesHandlersInterface(t *testing.T) {
//
//		// make and configure a mocked handlers.HandlersInterface
//		mockedHandlersInterface := &HandlersInterfaceMock{
//			GetPacksForItemsFunc: func(items int) map[int]int {
//				panic("mock out the GetPacksForItems method")
//			},
//			UpdatePacksFunc: func(packs []int) error {
//				panic("mock out the UpdatePacks method")
//			},
//		}
//
//		// use mockedHandlersInterface in code that requires handlers.HandlersInterface
//		// and then make assertions.
//
//	}
type HandlersInterfaceMock struct {
	// GetPacksForItemsFunc mocks the GetPacksForItems method.
	GetPacksForItemsFunc func(items int) map[int]int

	// UpdatePacksFunc mocks the UpdatePacks method.
	UpdatePacksFunc func(packs []int) error

	// calls tracks calls to the methods.
	calls struct {
		// GetPacksForItems holds details about calls to the GetPacksForItems method.
		GetPacksForItems []struct {
			// Items is the items argument value.
			Items int
		}
		// UpdatePacks holds details about calls to the UpdatePacks method.
		UpdatePacks []struct {
			// Packs is the packs argument value.
			Packs []int
		}
	}
	lockGetPacksForItems sync.RWMutex
	lockUpdatePacks      sync.RWMutex
}

// GetPacksForItems calls GetPacksForItemsFunc.
func (mock *HandlersInterfaceMock) GetPacksForItems(items int) map[int]int {
	if mock.GetPacksForItemsFunc == nil {
		panic("HandlersInterfaceMock.GetPacksForItemsFunc: method is nil but HandlersInterface.GetPacksForItems was just called")
	}
	callInfo := struct {
		Items int
	}{
		Items: items,
	}
	mock.lockGetPacksForItems.Lock()
	mock.calls.GetPacksForItems = append(mock.calls.GetPacksForItems, callInfo)
	mock.lockGetPacksForItems.Unlock()
	return mock.GetPacksForItemsFunc(items)
}

// GetPacksForItemsCalls gets all the calls that were made to GetPacksForItems.
// Check the length with:
//
//	len(mockedHandlersInterface.GetPacksForItemsCalls())
func (mock *HandlersInterfaceMock) GetPacksForItemsCalls() []struct {
	Items int
} {
	var calls []struct {
		Items int
	}
	mock.lockGetPacksForItems.RLock()
	calls = mock.calls.GetPacksForItems
	mock.lockGetPacksForItems.RUnlock()
	return calls
}

// UpdatePacks calls UpdatePacksFunc.
func (mock *HandlersInterfaceMock) UpdatePacks(packs []int) error {
	if mock.UpdatePacksFunc == nil {
		panic("HandlersInterfaceMock.UpdatePacksFunc: method is nil but HandlersInterface.UpdatePacks was just called")
	}
	callInfo := struct {
		Packs []int
	}{
		Packs: packs,
	}
	mock.lockUpdatePacks.Lock()
	mock.calls.UpdatePacks = append(mock.calls.UpdatePacks, callInfo)
	mock.lockUpdatePacks.Unlock()
	return mock.UpdatePacksFunc(packs)
}

// UpdatePacksCalls gets all the calls that were made to UpdatePacks.
// Check the length with:
//
//	len(mockedHandlersInterface.UpdatePacksCalls())
func (mock *HandlersInterfaceMock) UpdatePacksCalls() []struct {
	Packs []int
} {
	var calls []struct {
		Packs []int
	}
	mock.lockUpdatePacks.RLock()
	calls = mock.calls.UpdatePacks
	mock.lockUpdatePacks.RUnlock()
	return calls
}
